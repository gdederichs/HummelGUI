# Lab Notebook – Report up to 31.03.24
A main problem with the current GUI in use is the disabling of the DS5 current generators upon stopping of a task when using triggers to start that task. Also, having the capability to modify a function while a task is running is crucial for future studies of non-invasive brain stimulations such as Temporal Interference. Both these implementations require correct implmentation of the stopping of a task being output to a data aquisition system (DAQ). Below is the detailed summary of information I have gathered up to the 31st of March 2024.

## Implementation in MATLAB
My main hypothesis for the spike and subsequent crash of DS5 is that it is due to an improper closing of a task (signal being written to the DAQ). The reasoning behind this hypothesis is that once a task is written/sent to the DAQ, it is not up to the code to manage the voltage output, but rather the DAQ. Therefore, once commanded to be sent to the DAQ, all data points are already stored in the DAQ and are output further one by one following a certain timing rule specific to the DAQ. The MATLAB library dealing with data acquisition has a function to close these tasks, while the DAQ is controlling the voltage output. However, my leading hypothesis is that, once called, the command line forces the DAQ to release all data points at once (as it is an instantaneous function), thus creating a spike in voltage, translated to a spike in current in the DS5. This spike is extremely short in time, but it crosses the limit of the DS5 (for patient safety), thus disabling the DS5.

Supporting this hypothesis is tests that can be run through NI software. In particular, I have examined the functionalities of [NI-MAX](https://www.ni.com/en/support/documentation/supplemental/21/what-is-ni-measurement---automation-explorer--ni-max--.html) (NI measurement and automation explorer), to test different hardware. Through the “test panel” of the selected DAQ device, one can input and output different functions (constant or sinewave), at different amplitudes and frequencies. In particular, it also contains a “STOP” button to stop the writing of data, when testing “Analog Output”. Running the tests, I have found that there is no error when continuously writing the sinewave to the DAQ (and subsequently to the DS5). On the contrary, without exception, calling the stop function through the “STOP” button (as in the GUI) disables the DS5. This may show that, even with code proposed by NI themselves, stopping a task while it outputs voltage could yield an improper closing of tasks, leading to the consequences described above.

Also, in simple tests implemented in Python through the “nidaqmx” library, similar results occur. Indeed, continuous sinewaves can be written to the DAQ to be output to DS5, however when killing the terminal running the code (i.e. improper task closing), the DS5 are disabled in the same manner (same spike and timing observed on the oscillator) as the cases described above.

Standing against this hypothesis is the current GUI in use. When the writing to the DAQ is not started by a trigger (current ramp), the waveform can be interrupted. However, as soon as a trigger is implemented in the task, the DS5 are disabled as previously described. This may indicate that not all types of writing to the DAQ are handled in the same manner, thus producing different outcomes. However, up to now, no method or function has been identified in which this “writing method” can be specified.

## Implementation in Python
Communication with NI DAQs is possible in python, and is supported by the “nidaqmx” library (see [main.py](../main.py)). Contrary to MATLAB, while a task is being output by the DAQ to DS5, no other functionalities are accessible. The execution of the code remains on the “task.write()” command. This may be by design, to avoid faulty task management and clearing as described for the case of MATLAB above. However, this limits the programming of “stop” and “update” functionalities, as code cannot execute further before the entire waveform has been output. 

To circumvent this feature, I have tried implementing a “subdivide()” function (see [main.py](../main.py) and [util.py](../util.py)), which takes an initial waveform to be written to the DAQ, and divides it in multiple segments of a given duration. Each segment is then individually sent to the DAQ in a loop, thus being able to interact with the DAQ between each segment. This could be used for stopping and updating functions currently being output. However, a slight delay between the start of each segment remains concerning and has not yet been tested on two channels. Having a delay in each channel could completely compromise the wanted interference. At this point, further tests are necessary to conclude if the delay is negligeable or not.

Another approach I am currently exploring is multithreading (see [gui_test.py](../gui_test.py) and [thread_test.py](../thread_test.py)). Multithreading is already in use in my test GUI, to avoid it freezing when the “task.write()” function is already in use. Indeed, without multithreading on the GUI, all buttons become inaccessible while a function is being run. This is by design from the “PyQT6” package. With only this multithreading (on the GUI), calling “task.stop()” waits for the task.write() function to finish. This is due to the fact that the multithreading processes the GUI on one thread and the program on the other. Therefore, it remains to be tested if an additional threading on the program itself could resolve the problem of stopping a program while it is writing, with correct task closing handling.

A problem encountered in the python library, but not on MATLAB is the timing of tasks. In the python library, the timing method of writing data points to and from the DAQ needs to be explicitly stated (see [timing_test_file.py](../timing_test_file.py)). This is not the case in MATLAB. When tested on simulated devices (a feature proposed by the NI-MAX software) all timing functionalities preform as expected. However, when testing on the physical DAQs (USB-6216), the only supported timing type is “On demand”. “On demand” timing writes all data points as fast as possible, without specifying a wanted frequency. This is a major problem I am still looking into to advance the research on the new GUI and test multiple hypotheses stated above. In particular, this will be tested on new DAQs, which may support other timing types offered by the Python package. 

## Next Implementations and Tests
I have described above the main findings, problems and hypotheses to build a new GUI. Here, I propose the concrete main steps I will next be exploring.

Firstly, I will implement multithreading one level lower than on the GUI. This will determine if a task can be stopped from another simultaneous thread without causing errors. If so, this will then be used to stop tasks with a GUI button, and a similar process will be used to update functions while the GUI runs. To do so, a “stop()” is called, followed by a new task to be written being calculated and a call to “write()”. All these steps would be implemented on a thread in parallel to the current task being run, which is then replaced by the new task.

Secondly, timing options of python will be tested on the new DAQs, to test if they are supported. If so, the correct frequencies of functions can be specified, and tests relating to multiple simultaneous outputs on multiple channels can be tested on Python. If not, python does not seem to be the primary choice for writing the GUI, and NI developers of the python package may be contacted for more details concerning this issue.

Thirdly, a simple GUI (start, stop and trigger) will be written from scratch in MATLAB, to test if the issue observed in the current GUI when using a trigger still occurs. If so, the hypothesis of the problem being at the level of data handling by the DAQ would become very convincing. If not, the problem is at the level of data handling by the MATLAB code (perhaps not clearing all running tasks).



